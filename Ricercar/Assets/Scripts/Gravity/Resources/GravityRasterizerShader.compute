#include "Assets/Scripts/Gravity/ShaderStuff.cginc"
#pragma kernel CalculateMassDistribution
#pragma kernel GenerateGravityMap
#pragma kernel ClearOutputBuffer

#define G 667.4
#define SIZE 256
#define MULTIPLICATION_FACTOR 10000.0
#define MAX_ABS_VAL 1.0

Texture2D<float4> ImageInput;
RWTexture2D<float4> GravityMapOutput;

RWStructuredBuffer<int> MassDistributionOutput;
AppendStructuredBuffer<float2> OccupiedTexelsAppendBuffer;
StructuredBuffer<float2> OccupiedTexelsStructuredBuffer;

float TestMassDistribution2;

StructuredBuffer<uint> OccupiedTexelsCount;
uint InputWidth;
uint InputHeight;

[numthreads(3, 1, 1)]
void ClearOutputBuffer(uint3 id : SV_DispatchThreadID)
{
    MassDistributionOutput[id.x] = 0;
}

[numthreads(1, 1, 1)]
void CalculateMassDistribution(uint3 id : SV_DispatchThreadID)
{
    // just count up all the "mass" in the image (the sum of all the alpha values)

    float4 texel = ImageInput[id.xy];
    
    InterlockedAdd(MassDistributionOutput[0], (int)(texel.a * MULTIPLICATION_FACTOR));

    if (texel.a > 0)
        OccupiedTexelsAppendBuffer.Append(float2(id.x, id.y));
}

[numthreads(32, 32, 1)]
void GenerateGravityMap(uint3 id : SV_DispatchThreadID)
{
    float massDistribution = (float)MassDistributionOutput[0] / MULTIPLICATION_FACTOR;

    //float2 position = id.xy;
    float2 position = float2(id.x, id.y);

    float3 totalGravityForce = float3(0, 0, 0);

    uint inputXOffset = (SIZE - InputWidth) / 2;
    uint inputYOffset = (SIZE - InputHeight) / 2;

    for (uint i = 0; i < OccupiedTexelsCount[0]; i++)
    {
        uint2 inputTexelPosition = OccupiedTexelsStructuredBuffer[i];

        float2 texelPosition = float2(inputTexelPosition.x + inputXOffset, inputTexelPosition.y + inputYOffset);
        uint x = (uint)texelPosition.x;
        uint y = (uint)texelPosition.y;

        //float2 sampleCoords = texelPosition - float2(TextureOutputOffset, TextureOutputOffset);

        int notSameTexel = or(when_neq(id.x, x), when_neq(id.y, y));

        float4 texel = ImageInput[inputTexelPosition];

        float mass = texel.a / massDistribution;

        // adding a tiny number prevents NaN
        float2 difference = (texelPosition - position) + 0.00000001;
        float2 direction = normalize(difference);
        float sqrMagnitude = dot(difference, difference);

        float forceMagnitude = G * mass / sqrMagnitude;
        float2 gravityForce = (direction * forceMagnitude);

        float towardsiness = dot(normalize(gravityForce), direction) * forceMagnitude;
        
        // not entirely sure whether this counts as branching,
        // i need a way to convert a nan to a zero.
        // https://stackoverflow.com/questions/4911400/shader-optimization-is-a-ternary-operator-equivalent-to-branching
        towardsiness = 0;//isnan(towardsiness) ? 0 : towardsiness;

        float3 contribution = float3(notSameTexel * gravityForce, towardsiness);
        totalGravityForce += contribution;
	}

    float2 centreOfMassContribution = position * ImageInput[id.xy].a / massDistribution;

    InterlockedAdd(MassDistributionOutput[1], (int)(centreOfMassContribution.x * MULTIPLICATION_FACTOR));
    InterlockedAdd(MassDistributionOutput[2], (int)(centreOfMassContribution.y * MULTIPLICATION_FACTOR));

    GravityMapOutput[position] = float4(totalGravityForce, 1);
}