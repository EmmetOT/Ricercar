#pragma kernel ComputeFullField
//#pragma kernel ComputePointForcesParallel
#pragma kernel ComputePointForcesSeries

#define G 667.4
#define THREAD_GROUP_SQRT 16
#define THREAD_GROUP_SIZE 256
#define HALF_BAKED_SIZE 128
#define FULL_BAKED_SIZE 256
#define DEGREES_TO_RADIANS 0.0174533
#define MAX_ABS_VAL 1.0

struct AttractorData
{
    float x;
    float y;
    int ignore;
    float mass;
    float radius;
    float surfaceGravityForce;

    int isLine;
    float lineStartX;
    float lineStartY;
    float lineEndX;
    float lineEndY;
};

struct RingAttractorData
{
    float2 position;
    int ignore;
    float mass;
    float radius;
    float startAngle;
    float endAngle;
    float2 startPosition;
    float2 endPosition;
};

struct BakedAttractorData
{
    float2 position;
    int ignore;
    float mass;
    float2 centreOfGravity;
    float rotation;
};

// 2d positions where z corresponds to mass of the point
StructuredBuffer<AttractorData> PointAttractors;
int PointCount;

StructuredBuffer<RingAttractorData> RingAttractors;
int RingCount;

StructuredBuffer<BakedAttractorData> BakedAttractors;
int BakedCount;
Texture2DArray<float4> BakedAttractorTextures;

RWStructuredBuffer<float2> PointForces;

// the resulting 2d array of gravity vectors,
// the z component represents the average "towardsiness" 
// of each point, i.e. a high negative value means
// the vector is moving away from other points, a high positive
// value means it's moving towards those points
RWTexture2D<float4> GravityFieldOutputTexture;

float4 BottomLeft;
float4 TopRight;

int when_eq(float x, float y) 
{
    return 1 - abs(sign(x - y));
}

int when_neq(float x, float y) 
{
    return abs(sign(x - y));
}

int when_gt(float x, float y) 
{
  return max(sign(x - y), 0);
}

int when_lt(float x, float y) 
{
    // 10 < 60?
    //  sign(60 - 10) = 1
    //  max(1, 0)
    //  1 
    return max(sign(y - x), 0);
}

int when_ge(float x, float y) 
{
  return 1 - when_lt(x, y);
}

int when_le(float x, float y) 
{
  return 1 - when_gt(x, y);
}

int and(int a, int b) 
{
  return a * b;
}

int or(int a, int b) 
{
  return min(a + b, 1);
}

int xor(int a, int b) 
{
  return (a + b) % 2;
}

int not(int a) 
{
  return 1 - a;
}

float2 ProjectPointOnLineSegment(float2 a, float2 b, float2 p)
{
    float2 diff = b - a;
    float diffMagnitude = length(diff);
    float2 lineDirection = diff / diffMagnitude;

    //get vector from point on line to point in space
    float2 linePointToLineDirection = p - a;

    // how far along the point is from a to b
    float t = dot(linePointToLineDirection, lineDirection);

    float2 projectedPoint = a + lineDirection * t;

    float2 pointVec = projectedPoint - a;

    float dotProduct = dot(pointVec, diff);

    float dotGreaterThanZero = when_gt(dotProduct, 0);
    float pointVecShorterThanDiff = when_le(length(pointVec), diffMagnitude);

    return lerp(a, lerp(b, projectedPoint, pointVecShorterThanDiff), dotGreaterThanZero);
}

bool Intersect(float one, float two, float three)
{
	return (two > three && (one >= two || one <= three)) || (one >= two && one <= three);
}

bool IsInArc(RingAttractorData data, float2 pos)
{
	return Intersect(atan2(pos.x - 0.5, pos.y - 0.5) * 57.295779, data.startAngle, data.endAngle);
}

float invLerp(float from, float to, float value) 
{
	return (value - from) / (to - from);
}

float2 rotate(float2 uv, float2 pivot, float rotation)
{
    float cosRot = cos(rotation);
    float sinRot = sin(rotation);
    float2x2 rotationMatrix = { cosRot, -sinRot, sinRot, cosRot };

    uv -= pivot;
    uv = mul(rotationMatrix, uv);
    uv += pivot;
    return uv;
}
			
[numthreads(THREAD_GROUP_SQRT, THREAD_GROUP_SQRT, 1)]
void ComputeFullField(uint3 id : SV_DispatchThreadID)
{
    float2 uv = id.xy;
    float2 position = float2(lerp(BottomLeft.x, TopRight.x, id.x / (THREAD_GROUP_SIZE - 1.0)), lerp(BottomLeft.y, TopRight.y, id.y / (THREAD_GROUP_SIZE - 1.0)));

    float3 result = float3(0, 0, 0);
    
    int validAttractors = 0;

    for (int i = 0; i < PointCount; i++)
    {
        AttractorData data = PointAttractors[i];
        int doNotCount = data.ignore;

        float2 pointPosition = float2(data.x + doNotCount, data.y + doNotCount);
        float2 lineStartPos = float2(data.lineStartX + doNotCount, data.lineStartY + doNotCount);
        float2 lineEndPos = float2(data.lineEndX + doNotCount, data.lineEndY + doNotCount);

        pointPosition = lerp(pointPosition, ProjectPointOnLineSegment(lineStartPos, lineEndPos, position), data.isLine);

        float mass = data.mass;

        float2 difference = pointPosition - position;

        float sqrMagnitude = dot(difference, difference);
        float magnitude = sqrt(sqrMagnitude);

        float2 direction = difference / magnitude;

        float forceMagnitude = G * mass / sqrMagnitude;

        if (data.isLine != 1)
        {
            float shellGravity = lerp(0, data.surfaceGravityForce, magnitude / max(data.radius, 0.0001));
            int insideShell = when_lt(magnitude, data.radius);

            forceMagnitude = lerp(forceMagnitude, shellGravity, insideShell);
		}

        float2 gravityForce = (1 - doNotCount) * (direction * forceMagnitude);
        float finalMagnitude = length(gravityForce);

        float towardsiness = dot(normalize(gravityForce), direction) * finalMagnitude;
        
        validAttractors += 1 - isnan(towardsiness);

        // not entirely sure whether this counts as branching,
        // i need a way to convert a nan to a zero.
        // https://stackoverflow.com/questions/4911400/shader-optimization-is-a-ternary-operator-equivalent-to-branching
        towardsiness = isnan(towardsiness) ? 0 : towardsiness;

        result += float3(gravityForce.x, gravityForce.y, towardsiness);
	}

    for (int j = 0; j < RingCount; j++)
    {
        RingAttractorData data = RingAttractors[j];
        int doNotCount = data.ignore;

        float2 direction = normalize(data.position - position);
        float2 difference;

        if (IsInArc(data, position))
        {
            // basic ring function
            difference = data.position - direction * data.radius - position;
		}
        else
        {
            float2 diffToStart = data.startPosition - position;
            float2 diffToEnd = data.endPosition - position;

            //if (length(diffToStart) < length(diffToEnd))
            //    difference = diffToStart;
            //else
                difference = (diffToStart + diffToEnd) * 2;
		}

        float sqrMagnitude = dot(difference, difference);
        float magnitude = sqrt(sqrMagnitude);

        direction = difference / magnitude;

        float forceMagnitude = G * data.mass / sqrMagnitude;

        float2 gravityForce = (1 - doNotCount) * (direction * forceMagnitude);
        float finalMagnitude = length(gravityForce);

        float towardsiness = dot(normalize(gravityForce), direction) * finalMagnitude;
        
        validAttractors += 1 - isnan(towardsiness);

        // not entirely sure whether this counts as branching,
        // i need a way to convert a nan to a zero.
        // https://stackoverflow.com/questions/4911400/shader-optimization-is-a-ternary-operator-equivalent-to-branching
        towardsiness = isnan(towardsiness) ? 0 : towardsiness;

        result += float3(gravityForce.x, gravityForce.y, towardsiness);
	}
    
    float2 bakedOrigin = float2(HALF_BAKED_SIZE, HALF_BAKED_SIZE);

    for (int k = 0; k < BakedCount; k++)
    {
        BakedAttractorData data = BakedAttractors[k];
        int doNotCount = data.ignore;

        float2 dataPos = float2(lerp(HALF_BAKED_SIZE, -HALF_BAKED_SIZE, invLerp(BottomLeft.x, TopRight.x, data.position.x)), 
                            lerp(HALF_BAKED_SIZE, -HALF_BAKED_SIZE, invLerp(BottomLeft.x, TopRight.x, data.position.y)));

        float2 coord = rotate(uv, bakedOrigin - dataPos, -data.rotation * DEGREES_TO_RADIANS) + dataPos;

        // first, we transform the texture and sample it to get the force "baked in"
        float4 texData = BakedAttractorTextures[float3(coord, k)];
        
        // values have to be scaled back to their true forms!
        //float2 gravityForce = float2(texData.x * 2 - MAX_ABS_VAL, texData.y * 2 - MAX_ABS_VAL) * data.mass;
        float2 gravityForce = texData * data.mass;

        // rotate force vectors by rotation of attractor
        float cosRot = cos(data.rotation * DEGREES_TO_RADIANS);
        float sinRot = sin(data.rotation * DEGREES_TO_RADIANS);
        float2x2 rotationMatrix = { cosRot, -sinRot, sinRot, cosRot };
        
        float2 bakedForce = mul(rotationMatrix, float2(gravityForce.x, gravityForce.y));

        // next, we calculate point gravity towards the centre of gravity, in case we're outside the texture

        float2 difference = data.position - position;

        float sqrMagnitude = dot(difference, difference);
        float magnitude = sqrt(sqrMagnitude);

        float2 direction = difference / magnitude;

        float forceMagnitude = 0.0181 * G * data.mass / sqrMagnitude;

        float2 pointForce = (1 - doNotCount) * (direction * forceMagnitude);
        
        // this determines whether we're inside or outside the baked texture
        float isOutsideBounds = or(or(when_le(coord.x, 0), when_le(coord.y, 0)), or(when_ge(coord.x, FULL_BAKED_SIZE), when_ge(coord.y, FULL_BAKED_SIZE)));

        result += float3(lerp(bakedForce, pointForce, isOutsideBounds), 0);
	}

    result.z /= validAttractors;
    
    GravityFieldOutputTexture[id.xy] = float4(result.x, result.y, 0, 1);
}

[numthreads(1, 1, 1)]
void ComputePointForcesSeries(uint3 id : SV_DispatchThreadID)
{
    float2 result = float2(0, 0);

    // this kernel computes the attraction from this point to every other point

    AttractorData currentPoint = PointAttractors[id.x];
    float2 position = float2(currentPoint.x, currentPoint.y);
    float mass = currentPoint.mass;

    for (int i = 0; i < PointCount; i++)
    {
        AttractorData otherPoint = PointAttractors[i];

        // we dont want to add the gravity 
        // for the attractor to itself. this value returns 1 if the indices are equal,
        // else 0
        // we also use this to disable gravitation towards certain objects
        int doNotCount = or(otherPoint.ignore, when_eq(i, id.x));

        // adding the value here to prevent a division by 0. it doesn't matter, this calculation
        // will be discarded anyway
        float2 otherPosition = float2(otherPoint.x + doNotCount, otherPoint.y + doNotCount);

        // calculate for lines
        float2 lineStartPos = float2(otherPoint.lineStartX + doNotCount, otherPoint.lineStartY + doNotCount);
        float2 lineEndPos = float2(otherPoint.lineEndX + doNotCount, otherPoint.lineEndY + doNotCount);

        otherPosition = lerp(otherPosition, ProjectPointOnLineSegment(lineStartPos, lineEndPos, position), otherPoint.isLine);

        float otherMass = otherPoint.mass;

        float2 difference = otherPosition - position;

        float sqrMagnitude = difference.x * difference.x + difference.y * difference.y;
        float magnitude = sqrt(sqrMagnitude);

        float2 direction = difference / magnitude;

        float forceMagnitude = (G * mass * otherMass) / sqrMagnitude;

        // account for gravity radius: if we're within the radius of the attracting object,
        // force of gravity approaches zero 
        
        //if (magnitude < otherPoint.radius)
        //     forceMagnitude = lerp(0, otherPoint.surfaceGravityForce, magnitude / otherPoint.radius);

        float shellGravity = lerp(0, otherPoint.surfaceGravityForce, magnitude / max(otherPoint.radius, 0.0001));
        int insideShell = when_lt(magnitude, otherPoint.radius);

        forceMagnitude = lerp(forceMagnitude, shellGravity, insideShell);

        result += (1 - doNotCount) * (direction * forceMagnitude);
    }

    for (int j = 0; j < RingCount; j++)
    {
        RingAttractorData data = RingAttractors[j];
        int doNotCount = or(data.ignore, when_eq(i, id.x));

        float2 direction = normalize(data.position - position);
        float2 difference;

        if (IsInArc(data, position))
        {
            // basic ring function
            difference = data.position - direction * data.radius - position;
		}
        else
        {
            float2 diffToStart = data.startPosition - position;
            float2 diffToEnd = data.endPosition - position;

            if (length(diffToStart) < length(diffToEnd))
                difference = diffToStart;
            else
                difference = diffToEnd;
		}

        float sqrMagnitude = difference.x * difference.x + difference.y * difference.y;
        float magnitude = sqrt(sqrMagnitude);

        direction = difference / magnitude;

        float forceMagnitude = G * data.mass / sqrMagnitude;

        result += (1 - doNotCount) * (direction * forceMagnitude);
	}

    PointForces[id.x] = result;
}