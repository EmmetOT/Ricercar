#pragma kernel ComputeFullField
#pragma kernel ComputePointForcesParallel
#pragma kernel ComputePointForcesSeries

#define G 667.4
#define THREAD_GROUP_SQRT 16
#define THREAD_GROUP_SIZE 256

struct AttractorData
{
    float x;
    float y;
    int ignore;
    float mass;
    float radius;
    float surfaceGravityForce;

    int isLine;
    float lineStartX;
    float lineStartY;
    float lineEndX;
    float lineEndY;
};

struct AtomicVector2
{
    int X;
    int Y;
};

// the resulting 2d array of gravity vectors
RWStructuredBuffer<float2> GravityField;

// 2d positions where z corresponds to mass of the point
StructuredBuffer<AttractorData> PointAttractors;
RWStructuredBuffer<float2> PointForces;

RWStructuredBuffer<AtomicVector2> AtomicForcesOutputBuffer;

int PointCount;

float4 BottomLeft;
float4 TopRight;

int when_eq(float x, float y) 
{
    return 1 - abs(sign(x - y));
}

int when_neq(float x, float y) 
{
    return abs(sign(x - y));
}

int when_gt(float x, float y) 
{
  return max(sign(x - y), 0);
}

int when_lt(float x, float y) 
{
    // 10 < 60?
    //  sign(60 - 10) = 1
    //  max(1, 0)
    //  1 
    return max(sign(y - x), 0);
}

int when_ge(float x, float y) 
{
  return 1 - when_lt(x, y);
}

int when_le(float x, float y) 
{
  return 1 - when_gt(x, y);
}

int and(int a, int b) 
{
  return a * b;
}

int or(int a, int b) 
{
  return min(a + b, 1);
}

int xor(int a, int b) 
{
  return (a + b) % 2;
}

int not(int a) 
{
  return 1 - a;
}

float2 ProjectPointOnLineSegment(float2 a, float2 b, float2 p)
{
    float2 diff = b - a;
    float diffMagnitude = length(diff);
    float2 lineDirection = diff / diffMagnitude;

    //get vector from point on line to point in space
    float2 linePointToLineDirection = p - a;

    // how far along the point is from a to b
    float t = dot(linePointToLineDirection, lineDirection);

    float2 projectedPoint = a + lineDirection * t;

    float2 pointVec = projectedPoint - a;

    float dotProduct = dot(pointVec, diff);

    float dotGreaterThanZero = when_gt(dotProduct, 0);
    float pointVecShorterThanDiff = when_le(length(pointVec), diffMagnitude);

    return lerp(a, lerp(b, projectedPoint, pointVecShorterThanDiff), dotGreaterThanZero);
}

[numthreads(THREAD_GROUP_SQRT, THREAD_GROUP_SQRT, 1)]
void ComputeFullField(uint3 id : SV_DispatchThreadID)
{
    float2 position = float2(id.x, id.y);

    position = float2(lerp(BottomLeft.x, TopRight.x, id.x / (THREAD_GROUP_SIZE - 1.0)), lerp(BottomLeft.y, TopRight.y, id.y / (THREAD_GROUP_SIZE - 1.0)));

    float2 result = float2(0, 0);
    
    for (int i = 0; i < PointCount; i++)
    {
        AttractorData otherPoint = PointAttractors[i];
        int doNotCount = otherPoint.ignore;

        float2 pointPosition = float2(otherPoint.x + doNotCount, otherPoint.y + doNotCount);
        float2 lineStartPos = float2(otherPoint.lineStartX + doNotCount, otherPoint.lineStartY + doNotCount);
        float2 lineEndPos = float2(otherPoint.lineEndX + doNotCount, otherPoint.lineEndY + doNotCount);

        pointPosition = lerp(pointPosition, ProjectPointOnLineSegment(lineStartPos, lineEndPos, position), otherPoint.isLine);

        float mass = otherPoint.mass;

        float2 difference = pointPosition - position;

        float sqrMagnitude = difference.x * difference.x + difference.y * difference.y;
        float magnitude = sqrt(sqrMagnitude);

        float2 direction = difference / magnitude;

        float forceMagnitude = G * mass / sqrMagnitude;

        if (otherPoint.isLine != 1)
        {
            float shellGravity = lerp(0, otherPoint.surfaceGravityForce, magnitude / max(otherPoint.radius, 0.0001));
            int insideShell = when_lt(magnitude, otherPoint.radius);

            forceMagnitude = lerp(forceMagnitude, shellGravity, insideShell);
		}

        result += (1 - doNotCount) * (direction * forceMagnitude);
	}

    GravityField[id.x + THREAD_GROUP_SIZE * id.y] = result;
}

[numthreads(1, 1, 1)]
void ComputePointForcesParallel(uint3 id : SV_DispatchThreadID)
{    
    // this kernel computes the attraction from this point to every other point
    
    //int doNotCount = or(currentPoint.ignore, when_eq(i, id.x));
    int doNotCount = when_eq(id.x, id.y);

    AttractorData pointOne = PointAttractors[id.x];
    AttractorData pointTwo = PointAttractors[id.y];
    
    float2 positionOne = float2(pointOne.x, pointOne.y);
    float2 positionTwo = float2(pointTwo.x + doNotCount, pointTwo.y + doNotCount);

    float massOne = pointOne.mass;
    float massTwo = pointTwo.mass;

    float2 difference = positionTwo - positionOne;

    float sqrMagnitude = difference.x * difference.x + difference.y * difference.y;
    float magnitude = sqrt(sqrMagnitude);

    float2 direction = difference / magnitude;

    float forceMagnitude = (1000 * G * massOne * massTwo) / sqrMagnitude;

    float2 forceVec = (1 - doNotCount) * (direction * forceMagnitude);

    int resultX = (int)forceVec.x;
    int resultY = (int)forceVec.y;
    
    InterlockedAdd(AtomicForcesOutputBuffer[id.x].X, resultX);
    InterlockedAdd(AtomicForcesOutputBuffer[id.x].Y, resultY);

    InterlockedAdd(AtomicForcesOutputBuffer[id.y].X, -resultX);
    InterlockedAdd(AtomicForcesOutputBuffer[id.y].Y, -resultY);
}

[numthreads(1, 1, 1)]
void ComputePointForcesSeries(uint3 id : SV_DispatchThreadID)
{
    float2 result = float2(0, 0);

    // this kernel computes the attraction from this point to every other point

    AttractorData currentPoint = PointAttractors[id.x];
    float2 position = float2(currentPoint.x, currentPoint.y);
    float mass = currentPoint.mass;

    for (int i = 0; i < PointCount; i++)
    {
        AttractorData otherPoint = PointAttractors[i];

        // we dont want to add the gravity 
        // for the attractor to itself. this value returns 1 if the indices are equal,
        // else 0
        // we also use this to disable gravitation towards certain objects
        int doNotCount = or(otherPoint.ignore, when_eq(i, id.x));

        // adding the value here to prevent a division by 0. it doesn't matter, this calculation
        // will be discarded anyway
        float2 otherPosition = float2(otherPoint.x + doNotCount, otherPoint.y + doNotCount);

        // calculate for lines
        float2 lineStartPos = float2(otherPoint.lineStartX + doNotCount, otherPoint.lineStartY + doNotCount);
        float2 lineEndPos = float2(otherPoint.lineEndX + doNotCount, otherPoint.lineEndY + doNotCount);

        otherPosition = lerp(otherPosition, ProjectPointOnLineSegment(lineStartPos, lineEndPos, position), otherPoint.isLine);

        float otherMass = otherPoint.mass;

        float2 difference = otherPosition - position;

        float sqrMagnitude = difference.x * difference.x + difference.y * difference.y;
        float magnitude = sqrt(sqrMagnitude);

        float2 direction = difference / magnitude;

        float forceMagnitude = (G * mass * otherMass) / sqrMagnitude;

        // account for gravity radius: if we're within the radius of the attracting object,
        // force of gravity approaches zero 
        
        //if (magnitude < otherPoint.radius)
        //     forceMagnitude = lerp(0, otherPoint.surfaceGravityForce, magnitude / otherPoint.radius);

        float shellGravity = lerp(0, otherPoint.surfaceGravityForce, magnitude / max(otherPoint.radius, 0.0001));
        int insideShell = when_lt(magnitude, otherPoint.radius);

        forceMagnitude = lerp(forceMagnitude, shellGravity, insideShell);

        result += (1 - doNotCount) * (direction * forceMagnitude);
    }

    PointForces[id.x] = result;
}